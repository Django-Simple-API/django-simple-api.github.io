{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Simple API About Us Django Simple API is a non-intrusive component that can help you quickly create APIs. It's not an API framework, it's just a lightweight Django-based plugin that's very easy to learn and use. It has two core functions: Automatic generation of interface documents Automatic validation of request parameters To help us develop faster, we also extended support for application/json requests and provided some useful utility functions. Learn and used \u26a0\ufe0f We support both view-function and class-view at the same time for all functions. If there is no special description in the document, it means that it is applicable to both views. Where special support is needed, we will indicate how to do it in the document. Quick Start Declare Parameters Parameter Verification Document Generation","title":"Homepage"},{"location":"#django-simple-api","text":"","title":"Django Simple API"},{"location":"#about-us","text":"Django Simple API is a non-intrusive component that can help you quickly create APIs. It's not an API framework, it's just a lightweight Django-based plugin that's very easy to learn and use. It has two core functions: Automatic generation of interface documents Automatic validation of request parameters To help us develop faster, we also extended support for application/json requests and provided some useful utility functions.","title":"About Us"},{"location":"#learn-and-used","text":"\u26a0\ufe0f We support both view-function and class-view at the same time for all functions. If there is no special description in the document, it means that it is applicable to both views. Where special support is needed, we will indicate how to do it in the document. Quick Start Declare Parameters Parameter Verification Document Generation","title":"Learn and used"},{"location":"declare-parameters/","text":"Parameter declaration is the infrastructure of Simple API . Whether you want to automatically verify request parameters or automatically generate interface documents, you must first learn how to declare parameters. You can declare request parameters like the following example: # views.py from django.views import View from django.http.response import HttpResponse from django_simple_api import Query class JustTest ( View ): def get ( self , request , # `id` is your parameter name. # `int` is your parameter type. # `Query` represents where your parameters are located, # and can describe various information about your parameters. id : int = Query () ): return HttpResponse ( id ) Fields Simple API has a total of 6 fields, corresponding to the parameters in different positions: All fields and description Field Description Query Indicates that this parameter is in the url query string. example: http://host/?param=1 Path Indicates that this parameter is a url path parameter. example: http://host/{param}/ Body Indicates that this parameter is in the request body, and the value can only be obtained in a non-GET request. Cookie Indicates that this parameter is in Cookie. Header Indicates that this parameter is in Header. Exclusive This is a special field, its parameter type should be subclass of pydantic.BaseModel , it will get all the parameters from the location specified by Exclusive . For example: # urls.py urlpatterns = [ ... path ( \"/path/<param2>/<param3>/\" , JustTest . as_view (), name = \"path_name\" ), ] # views.py from django_simple_api import Query , Path , Body , Cookie , Header class JustTest ( View ): # The parameter names used in the above examples are for demonstration only. def post ( self , request , param1 : int = Query (), # You can use the same field to describe multiple parameters. param2 : int = Path (), param3 : int = Path (), param4 : str = Body (), userid : int = Cookie ( alias = \"uid\" ), username : int = Cookie ( alias = \"username\" ), csrf_token : str = Header ( alias = \"X-Csrf-Token\" ), ): return HttpResponse ( d ) \u26a0\ufe0f In the above example, you have two things to note: If you have more than one parameter in a field, you can use the field multiple times to describe different parameters (except for the 'Exclusive' field). When you need to get parameters from Header , you may need to use alias to indicate the request header you want to get, because the name of the request header may not be a valid python identifier. Exclusive is a special field that can obtain all the parameters required by the entire data model from a specified location at one time. Here's has a example of how to combine Exclusive with Django Model , now suppose you have the following Model: # models.py from django.db import models class UserModel ( models . Model ): name = models . CharField ( max_length = 25 ) age = models . SmallIntegerField ( default = 19 ) You can use pydantic.BaseModel to define a \"Form\" \uff0c Then use the Exclusive field to get all parameters required for \"Form\" from the body : # views.py from django.views import View from pydantic import BaseModel , Field from django_simple_api import Exclusive # Use `pydantic.BaseModel` to define a `\"Form\"` class UserForm ( BaseModel ): name : str = Field ( max_length = 25 , description = \"This is user's name\" ) age : int = Field ( 19 , description = \"This is user's age\" ) class UserView ( View ): def post ( self , request , # Use the `Exclusive` field to get all parameters required for `\"Form\"` from the `body`: user : UserForm = Exclusive ( name = \"body\" ) ): # You can get the parameters from the \"Form\" like this: name = user . name age = user . age # Also convert the form into a dictionary: user . dict () # {\"name\": ..., \"age\": ...} # So you can directly instantiate the UserModel like this: UserModel ( ** user . dict ()) . save () return HttpResponse ( \"success\" ) \u26a0\ufe0f Note, when you use Exclusive(\"body\") to get the form from a specified location, you can no longer use the Body field, but use of other fields will not be affected. There are other uses of BaseModel , see pydantic for more details. Type conversion As you can see in the above example, Simple API also has the function of type conversion. If the parameter you pass in is legal for the declared type, it will be converted to the declared type without manual operation: # views.py class JustTest ( View ): def get ( self , request , last_time : datetime . date = Query ()): print ( last_time , type ( last_time )) # 2008-08-08 <class 'datetime.date'> return HttpResponse ( last_time ) Field properties Use Query() to declare the parameter, which means this parameter is required. If there is no id parameter in the query string for url, an error will be returned: [ { \"loc\" : [ \"id\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] In addition to this, you can use default parameters like this: # views.py class JustTest ( View ): def get ( self , request , id : int = Query ( 10 )): return HttpResponse ( id ) # equivalent to def get ( self , request , id : int = Query ( default = 10 )): return HttpResponse ( id ) Or you can use the default_factory parameter and pass in a function to dynamically calculate the default value: # views.py def func (): return 1000 class JustTest ( View ): def get ( self , request , id : int = Query ( default_factory = func )): print ( id ) # 1000 return HttpResponse ( id ) But you cannot use default and default_factory at the same time, otherwise an error will be reported: ValueError: cannot specify both default and default_factory In addition to the default \u3001 default_factory , you can also use more attributes to constrain parameters, such as: # views.py class JustTest ( View ): # Use `const` to constrain the parameter value must be the same as the default value def get ( self , request , param : int = Query ( 10 , const = True )): print ( param , type ( param )) return HttpResponse ( param ) # If your parameter is of numeric type , you can use `ge`\u3001`gt`\u3001`le`\u3001`lt`\u3001`multipleOf` and other attributes def get ( self , request , param1 : int = Query ( gt = 10 ), # must be > 10 param2 : int = Query ( ge = 10 ), # must be >= 10 param3 : int = Query ( lt = 10 ), # must be < 10 param4 : int = Query ( le = 10 ), # must be <= 10 param5 : int = Query ( multipleOf = 10 ), # must be a multiple of 10 ): return HttpResponse ( param ) And there are more attributes applied to str or list type, you can refer to the following table: All properties and description Name description default since this is replacing the field\u2019s default, its first argument is used to set the default, do not pass default or default_factory to indicate that this is a required field default_factory callable that will be called when a default value is needed for this field. If both default and default_factory are set, an error is raised. alias the public name of the field title can be any string, used in the schema description can be any string, used in the schema const this field is required and must take it's default value gt only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword ge only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword lt only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword le only applies to numbers, requires the field to be \"less than or equal to\". The schema will have a maximum validation keyword multiple_of only applies to numbers, requires the field to be \"a multiple of\". The schema will have a multipleOf validation keyword min_items only applies to list or tuple and set, requires the field to have a minimum length. max_items only applies to list or tuple and set, requires the field to have a maximum length. min_length only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword max_length only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword regex only applies to strings, requires the field match again a regular expression pattern string. The schema will have a pattern validation keyword extra any additional keyword arguments will be added as is to the schema More When you finish the above tutorial, you can already declare parameters well. Next, you can use the functions of \"parameter verification\" and \"document generation\". Click Parameter Verification to see how to verify parameters. Click Document Generation to see how to Generating documentation.","title":"Declare Parameters"},{"location":"declare-parameters/#fields","text":"Simple API has a total of 6 fields, corresponding to the parameters in different positions:","title":"Fields"},{"location":"declare-parameters/#all-fields-and-description","text":"Field Description Query Indicates that this parameter is in the url query string. example: http://host/?param=1 Path Indicates that this parameter is a url path parameter. example: http://host/{param}/ Body Indicates that this parameter is in the request body, and the value can only be obtained in a non-GET request. Cookie Indicates that this parameter is in Cookie. Header Indicates that this parameter is in Header. Exclusive This is a special field, its parameter type should be subclass of pydantic.BaseModel , it will get all the parameters from the location specified by Exclusive .","title":"All fields and description"},{"location":"declare-parameters/#for-example","text":"# urls.py urlpatterns = [ ... path ( \"/path/<param2>/<param3>/\" , JustTest . as_view (), name = \"path_name\" ), ] # views.py from django_simple_api import Query , Path , Body , Cookie , Header class JustTest ( View ): # The parameter names used in the above examples are for demonstration only. def post ( self , request , param1 : int = Query (), # You can use the same field to describe multiple parameters. param2 : int = Path (), param3 : int = Path (), param4 : str = Body (), userid : int = Cookie ( alias = \"uid\" ), username : int = Cookie ( alias = \"username\" ), csrf_token : str = Header ( alias = \"X-Csrf-Token\" ), ): return HttpResponse ( d ) \u26a0\ufe0f In the above example, you have two things to note: If you have more than one parameter in a field, you can use the field multiple times to describe different parameters (except for the 'Exclusive' field). When you need to get parameters from Header , you may need to use alias to indicate the request header you want to get, because the name of the request header may not be a valid python identifier. Exclusive is a special field that can obtain all the parameters required by the entire data model from a specified location at one time. Here's has a example of how to combine Exclusive with Django Model , now suppose you have the following Model: # models.py from django.db import models class UserModel ( models . Model ): name = models . CharField ( max_length = 25 ) age = models . SmallIntegerField ( default = 19 ) You can use pydantic.BaseModel to define a \"Form\" \uff0c Then use the Exclusive field to get all parameters required for \"Form\" from the body : # views.py from django.views import View from pydantic import BaseModel , Field from django_simple_api import Exclusive # Use `pydantic.BaseModel` to define a `\"Form\"` class UserForm ( BaseModel ): name : str = Field ( max_length = 25 , description = \"This is user's name\" ) age : int = Field ( 19 , description = \"This is user's age\" ) class UserView ( View ): def post ( self , request , # Use the `Exclusive` field to get all parameters required for `\"Form\"` from the `body`: user : UserForm = Exclusive ( name = \"body\" ) ): # You can get the parameters from the \"Form\" like this: name = user . name age = user . age # Also convert the form into a dictionary: user . dict () # {\"name\": ..., \"age\": ...} # So you can directly instantiate the UserModel like this: UserModel ( ** user . dict ()) . save () return HttpResponse ( \"success\" ) \u26a0\ufe0f Note, when you use Exclusive(\"body\") to get the form from a specified location, you can no longer use the Body field, but use of other fields will not be affected. There are other uses of BaseModel , see pydantic for more details.","title":"For example:"},{"location":"declare-parameters/#type-conversion","text":"As you can see in the above example, Simple API also has the function of type conversion. If the parameter you pass in is legal for the declared type, it will be converted to the declared type without manual operation: # views.py class JustTest ( View ): def get ( self , request , last_time : datetime . date = Query ()): print ( last_time , type ( last_time )) # 2008-08-08 <class 'datetime.date'> return HttpResponse ( last_time )","title":"Type conversion"},{"location":"declare-parameters/#field-properties","text":"Use Query() to declare the parameter, which means this parameter is required. If there is no id parameter in the query string for url, an error will be returned: [ { \"loc\" : [ \"id\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] In addition to this, you can use default parameters like this: # views.py class JustTest ( View ): def get ( self , request , id : int = Query ( 10 )): return HttpResponse ( id ) # equivalent to def get ( self , request , id : int = Query ( default = 10 )): return HttpResponse ( id ) Or you can use the default_factory parameter and pass in a function to dynamically calculate the default value: # views.py def func (): return 1000 class JustTest ( View ): def get ( self , request , id : int = Query ( default_factory = func )): print ( id ) # 1000 return HttpResponse ( id ) But you cannot use default and default_factory at the same time, otherwise an error will be reported: ValueError: cannot specify both default and default_factory In addition to the default \u3001 default_factory , you can also use more attributes to constrain parameters, such as: # views.py class JustTest ( View ): # Use `const` to constrain the parameter value must be the same as the default value def get ( self , request , param : int = Query ( 10 , const = True )): print ( param , type ( param )) return HttpResponse ( param ) # If your parameter is of numeric type , you can use `ge`\u3001`gt`\u3001`le`\u3001`lt`\u3001`multipleOf` and other attributes def get ( self , request , param1 : int = Query ( gt = 10 ), # must be > 10 param2 : int = Query ( ge = 10 ), # must be >= 10 param3 : int = Query ( lt = 10 ), # must be < 10 param4 : int = Query ( le = 10 ), # must be <= 10 param5 : int = Query ( multipleOf = 10 ), # must be a multiple of 10 ): return HttpResponse ( param ) And there are more attributes applied to str or list type, you can refer to the following table:","title":"Field properties"},{"location":"declare-parameters/#all-properties-and-description","text":"Name description default since this is replacing the field\u2019s default, its first argument is used to set the default, do not pass default or default_factory to indicate that this is a required field default_factory callable that will be called when a default value is needed for this field. If both default and default_factory are set, an error is raised. alias the public name of the field title can be any string, used in the schema description can be any string, used in the schema const this field is required and must take it's default value gt only applies to numbers, requires the field to be \"greater than\". The schema will have an exclusiveMinimum validation keyword ge only applies to numbers, requires the field to be \"greater than or equal to\". The schema will have a minimum validation keyword lt only applies to numbers, requires the field to be \"less than\". The schema will have an exclusiveMaximum validation keyword le only applies to numbers, requires the field to be \"less than or equal to\". The schema will have a maximum validation keyword multiple_of only applies to numbers, requires the field to be \"a multiple of\". The schema will have a multipleOf validation keyword min_items only applies to list or tuple and set, requires the field to have a minimum length. max_items only applies to list or tuple and set, requires the field to have a maximum length. min_length only applies to strings, requires the field to have a minimum length. The schema will have a maximum validation keyword max_length only applies to strings, requires the field to have a maximum length. The schema will have a maxLength validation keyword regex only applies to strings, requires the field match again a regular expression pattern string. The schema will have a pattern validation keyword extra any additional keyword arguments will be added as is to the schema","title":"All properties and description"},{"location":"declare-parameters/#more","text":"When you finish the above tutorial, you can already declare parameters well. Next, you can use the functions of \"parameter verification\" and \"document generation\". Click Parameter Verification to see how to verify parameters. Click Document Generation to see how to Generating documentation.","title":"More"},{"location":"document-generation/","text":"Hints: If you want to automatically generate interface documentation, you must add the url of Simple API to your urls.py, See Quick Start . Modify the interface document description information You can modify the interface document description information in the url of Simple API , like this: # urls.py from django.urls import include , path from django.conf import settings # Your urls urlpatterns = [ ... ] # Simple API urls, should only run in a test environment. if settings . DEBUG : urlpatterns += [ # generate documentation path ( \"docs/\" , include ( \"django_simple_api.urls\" ), { \"template_name\" : \"swagger.html\" , \"title\" : \"Django Simple API\" , \"description\" : \"This is description of your interface document.\" , \"version\" : \"0.1.0\" , }, ), ] In the above example, you can modify the template_name to change the UI theme of the interface document, We currently have two UI themes: swagger.html and redoc.html . And then you can modify title \u3001 description and version to describe your interface documentation. Generate documentation for function-view If you are using class-view , you can now generate documentation. Start your service, if your service is running locally, you can visit http://127.0.0.1:8000/docs/ to view your documentation. But if you are using view-function , you must declare the request method supported by the view function: # views.py from django_simple_api import allow_request_method @allow_request_method ( \"get\" ) def just_test ( request , id : int = Query ()): return HttpResponse ( id ) allow_request_method can only declare one request method, and it must be in ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', trace'] . We do not support the behavior of using multiple request methods in a view-function , which will cause trouble for generating documentation. Note that if you use @allow_request_method(\"get\") to declare a request method, you will not be able to use request methods other than get , otherwise it will return 405 Method Not Allow . You can also not use allow_request_method , this will not have any negative effects, but it will not generate documentation. We will use warning.warn() to remind you, this is not a problem, just to prevent you from forgetting to use it. Now, the view-function can also generate documents, you can continue to visit your server to view the effect. Improve documentation information Simple API is generated according to the OpenAPI specification. In addition to automatically generating function parameters, you can also manually add some additional information to the view yourself, for example: summary description responses and tags . Add summary and description to the view summary and description can describe the information of your interface in the interface document, summary is used to briefly introduce the function of the interface, and description is used to describe more information. There must be a blank line between summary and description . If there is no blank line, then all doc will be considered as summary . # views.py class JustTest ( View ): def get ( self , request , id : int = Query ()): \"\"\" This is summary. This is description ... This is description ... \"\"\" return HttpResponse ( id ) Add responses to the view responses is also important information in the interface documentation. You can define the response information that the interface should return in various situations. Simple API highly recommends using pydantic.BaseModel to define the data structure of the response message, for example: # views.py from typing import List from pydantic import BaseModel from django.views import View from django_simple_api import describe_response # define the data structure for `response` class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class JustTest ( View ): # describe the response information of the interface @describe_response ( 200 , content = JustTestResponses ) def get ( self , request , id : int = Query ()): # actual response data(just an example) resp = { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" }, { \"id\" : 1 , \"name\" : \"John\" }, ] } return JsonResponse ( resp ) Then the interface document will show: { \"code\" : \"string\" , \"message\" : \"string\" , \"data\" : [ {} ] } You can also show the example in the interface document, you only need to add the example to the BaseModel and it will be shown in the interface document: # views.py class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class Config : schema_extra = { \"example\" : { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" }, { \"id\" : 1 , \"name\" : \"John\" }, ] } } class JustTest ( View ): @describe_response ( 200 , content = JustTestResponses ) def get ( self , request , id : int = Query ()): resp = { ... } return JsonResponse ( resp ) Then the interface document will show: { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" } , { \"id\" : 1 , \"name\" : \"John\" } ] } The default response type of Simple API is application/json , if you want to set other types, you can use it like this: # views.py class JustTest ( View ): @describe_response ( 401 , content = { \"text/plain\" :{ \"schema\" : { \"type\" : \"string\" , \"example\" : \"No permission\" }}}) def get ( self , request , id : int = Query ()): return JsonResponse ( id ) Although we support custom response types and data structures, we recommend that you try not to do this, unless it is a very simple response as in the example, otherwise it will take up a lot of space in your code files and it will not conducive to other people in the team to read the code. If you need to describe multiple responses, then we will recommend you to use describe_responses , which can describe multiple response states at once, this is equivalent to using multiple describe_response simultaneously: # views.py from django_simple_api import describe_responses class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class JustTest ( View ): @describe_responses ({ 200 : { \"content\" : JustTestResponses }, 401 : { \"content\" : { \"text/plain\" : { \"schema\" : { \"type\" : \"string\" , \"example\" : \"No permission\" }}}} }) def get ( self , request , id : int = Query ()): return JsonResponse ( id ) Add responses to multiple views simultaneously: wrapper_include Add tags to the view Tagging interfaces is a good way to manage many interfaces, That's how you tag a view: from django_simple_api import mark_tags , allow_request_method , Query @mark_tags ( \"about User\" ) @allow_request_method ( \"get\" ) def get_name ( request , id : int = Query ( ... )): return HttpResponse ( get_name_by_id ( id )) You can use @mark_tags(\"tag1\", \"tag2\") to tag a view with multiple tags Add tags to multiple views simultaneously: wrapper_include Extensions function wrapper_include We also support tagging multiple URLs at the same time from django_simple_api import wrapper_include , mark_tags urlpatterns = [ ... , path ( \"app/\" , wrapper_include ([ mark_tags ( \"demo tag\" )], include ( \"app.urls\" ))), ] The wrapper_include in the above code will add mark_tags decorators to all views configured in the app URLs You can also use the wrapper_include based functionality wrapper_include ([ mark_tags ( \"demo tag\" ), describe_response ( 200 , \"ok\" )], include ( \"app.urls\" )) describe_extra_docs Support for JSON requests To be continue ...","title":"Document Generation"},{"location":"document-generation/#modify-the-interface-document-description-information","text":"You can modify the interface document description information in the url of Simple API , like this: # urls.py from django.urls import include , path from django.conf import settings # Your urls urlpatterns = [ ... ] # Simple API urls, should only run in a test environment. if settings . DEBUG : urlpatterns += [ # generate documentation path ( \"docs/\" , include ( \"django_simple_api.urls\" ), { \"template_name\" : \"swagger.html\" , \"title\" : \"Django Simple API\" , \"description\" : \"This is description of your interface document.\" , \"version\" : \"0.1.0\" , }, ), ] In the above example, you can modify the template_name to change the UI theme of the interface document, We currently have two UI themes: swagger.html and redoc.html . And then you can modify title \u3001 description and version to describe your interface documentation.","title":"Modify the interface document description information"},{"location":"document-generation/#generate-documentation-for-function-view","text":"If you are using class-view , you can now generate documentation. Start your service, if your service is running locally, you can visit http://127.0.0.1:8000/docs/ to view your documentation. But if you are using view-function , you must declare the request method supported by the view function: # views.py from django_simple_api import allow_request_method @allow_request_method ( \"get\" ) def just_test ( request , id : int = Query ()): return HttpResponse ( id ) allow_request_method can only declare one request method, and it must be in ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', trace'] . We do not support the behavior of using multiple request methods in a view-function , which will cause trouble for generating documentation. Note that if you use @allow_request_method(\"get\") to declare a request method, you will not be able to use request methods other than get , otherwise it will return 405 Method Not Allow . You can also not use allow_request_method , this will not have any negative effects, but it will not generate documentation. We will use warning.warn() to remind you, this is not a problem, just to prevent you from forgetting to use it. Now, the view-function can also generate documents, you can continue to visit your server to view the effect.","title":"Generate documentation for function-view"},{"location":"document-generation/#improve-documentation-information","text":"Simple API is generated according to the OpenAPI specification. In addition to automatically generating function parameters, you can also manually add some additional information to the view yourself, for example: summary description responses and tags .","title":"Improve documentation information"},{"location":"document-generation/#add-summary-and-description-to-the-view","text":"summary and description can describe the information of your interface in the interface document, summary is used to briefly introduce the function of the interface, and description is used to describe more information. There must be a blank line between summary and description . If there is no blank line, then all doc will be considered as summary . # views.py class JustTest ( View ): def get ( self , request , id : int = Query ()): \"\"\" This is summary. This is description ... This is description ... \"\"\" return HttpResponse ( id )","title":"Add summary and description to the view"},{"location":"document-generation/#add-responses-to-the-view","text":"responses is also important information in the interface documentation. You can define the response information that the interface should return in various situations. Simple API highly recommends using pydantic.BaseModel to define the data structure of the response message, for example: # views.py from typing import List from pydantic import BaseModel from django.views import View from django_simple_api import describe_response # define the data structure for `response` class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class JustTest ( View ): # describe the response information of the interface @describe_response ( 200 , content = JustTestResponses ) def get ( self , request , id : int = Query ()): # actual response data(just an example) resp = { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" }, { \"id\" : 1 , \"name\" : \"John\" }, ] } return JsonResponse ( resp ) Then the interface document will show: { \"code\" : \"string\" , \"message\" : \"string\" , \"data\" : [ {} ] } You can also show the example in the interface document, you only need to add the example to the BaseModel and it will be shown in the interface document: # views.py class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class Config : schema_extra = { \"example\" : { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" }, { \"id\" : 1 , \"name\" : \"John\" }, ] } } class JustTest ( View ): @describe_response ( 200 , content = JustTestResponses ) def get ( self , request , id : int = Query ()): resp = { ... } return JsonResponse ( resp ) Then the interface document will show: { \"code\" : \"0\" , \"message\" : \"success\" , \"data\" : [ { \"id\" : 0 , \"name\" : \"Tom\" } , { \"id\" : 1 , \"name\" : \"John\" } ] } The default response type of Simple API is application/json , if you want to set other types, you can use it like this: # views.py class JustTest ( View ): @describe_response ( 401 , content = { \"text/plain\" :{ \"schema\" : { \"type\" : \"string\" , \"example\" : \"No permission\" }}}) def get ( self , request , id : int = Query ()): return JsonResponse ( id ) Although we support custom response types and data structures, we recommend that you try not to do this, unless it is a very simple response as in the example, otherwise it will take up a lot of space in your code files and it will not conducive to other people in the team to read the code. If you need to describe multiple responses, then we will recommend you to use describe_responses , which can describe multiple response states at once, this is equivalent to using multiple describe_response simultaneously: # views.py from django_simple_api import describe_responses class JustTestResponses ( BaseModel ): code : str message : str data : List [ dict ] class JustTest ( View ): @describe_responses ({ 200 : { \"content\" : JustTestResponses }, 401 : { \"content\" : { \"text/plain\" : { \"schema\" : { \"type\" : \"string\" , \"example\" : \"No permission\" }}}} }) def get ( self , request , id : int = Query ()): return JsonResponse ( id ) Add responses to multiple views simultaneously: wrapper_include","title":"Add responses to the view"},{"location":"document-generation/#add-tags-to-the-view","text":"Tagging interfaces is a good way to manage many interfaces, That's how you tag a view: from django_simple_api import mark_tags , allow_request_method , Query @mark_tags ( \"about User\" ) @allow_request_method ( \"get\" ) def get_name ( request , id : int = Query ( ... )): return HttpResponse ( get_name_by_id ( id )) You can use @mark_tags(\"tag1\", \"tag2\") to tag a view with multiple tags Add tags to multiple views simultaneously: wrapper_include","title":"Add tags to the view"},{"location":"document-generation/#extensions-function","text":"","title":"Extensions function"},{"location":"document-generation/#wrapper_include","text":"We also support tagging multiple URLs at the same time from django_simple_api import wrapper_include , mark_tags urlpatterns = [ ... , path ( \"app/\" , wrapper_include ([ mark_tags ( \"demo tag\" )], include ( \"app.urls\" ))), ] The wrapper_include in the above code will add mark_tags decorators to all views configured in the app URLs You can also use the wrapper_include based functionality wrapper_include ([ mark_tags ( \"demo tag\" ), describe_response ( 200 , \"ok\" )], include ( \"app.urls\" ))","title":"wrapper_include"},{"location":"document-generation/#describe_extra_docs","text":"","title":"describe_extra_docs"},{"location":"document-generation/#support-for-json-requests","text":"","title":"Support for JSON requests"},{"location":"document-generation/#to-be-continue","text":"","title":"To be continue ..."},{"location":"parameter-verification/","text":"Hints: Don't forget to install the app and register the middleware. See Quick Start . \"Parameter verification\" is enabled by default. When you declare a parameter using \" Fields \", the Simple API will automatically checks whether the parameter is valid in the request. If your parameter verification fails, an error will be returned, like this: [ { \"loc\" : [ \"id\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] In the error message above, loc indicates which parameter has an error, msg describes the cause of the error. With this information, you can quickly locate the problem of parameters.","title":"Parameter Verification"},{"location":"quick-start/","text":"Install Download and install from github: pip install git+https://github.com/Django-Simple-API/django-simple-api.git@setup.py Or from coding mirror in China: pip install git+https://e.coding.net/aber/github/django-simple-api.git@setup.py Configure Add django-simple-api to your INSTALLED_APPS in settings: INSTALLED_APPS = [ ... , \"django_simple_api\" , ] Register the middleware to your MIDDLEWARE in settings: MIDDLEWARE = [ ... , \"django_simple_api.middleware.SimpleApiMiddleware\" , ] Add the url of django-simple-api to your urls.py: # urls.py from django.urls import include , path from django.conf import settings # Your urls urlpatterns = [ ... ] # Simple API urls, should only run in a test environment. if settings . DEBUG : urlpatterns += [ # generate documentation path ( \"docs/\" , include ( \"django_simple_api.urls\" )) ] Complete the first example Define your url: # your urls.py from django.urls import path from yourviews import JustTest urlpatterns = [ ... , path ( \"/path/<id:int>/\" , JustTest . as_view ()), ] Define your view: # your views.py from django.views import View from django.http.response import HttpResponse from django_simple_api import Query class JustTest ( View ): def get ( self , request , id : int = Query ()): return HttpResponse ( id ) To generate the document, you must declare the parameters according to the rules of Simple API (like the example above). Click Declare parameters to see how to declare parameters. Access interface document After the above configuration, you can start your server and access the interface documentation now. If your service is running locally, you can visit http://127.0.0.1:8000/docs/ to view your documentation.","title":"Quick Start"},{"location":"quick-start/#install","text":"Download and install from github: pip install git+https://github.com/Django-Simple-API/django-simple-api.git@setup.py Or from coding mirror in China: pip install git+https://e.coding.net/aber/github/django-simple-api.git@setup.py","title":"Install"},{"location":"quick-start/#configure","text":"Add django-simple-api to your INSTALLED_APPS in settings: INSTALLED_APPS = [ ... , \"django_simple_api\" , ] Register the middleware to your MIDDLEWARE in settings: MIDDLEWARE = [ ... , \"django_simple_api.middleware.SimpleApiMiddleware\" , ] Add the url of django-simple-api to your urls.py: # urls.py from django.urls import include , path from django.conf import settings # Your urls urlpatterns = [ ... ] # Simple API urls, should only run in a test environment. if settings . DEBUG : urlpatterns += [ # generate documentation path ( \"docs/\" , include ( \"django_simple_api.urls\" )) ]","title":"Configure"},{"location":"quick-start/#complete-the-first-example","text":"Define your url: # your urls.py from django.urls import path from yourviews import JustTest urlpatterns = [ ... , path ( \"/path/<id:int>/\" , JustTest . as_view ()), ] Define your view: # your views.py from django.views import View from django.http.response import HttpResponse from django_simple_api import Query class JustTest ( View ): def get ( self , request , id : int = Query ()): return HttpResponse ( id ) To generate the document, you must declare the parameters according to the rules of Simple API (like the example above). Click Declare parameters to see how to declare parameters.","title":"Complete the first example"},{"location":"quick-start/#access-interface-document","text":"After the above configuration, you can start your server and access the interface documentation now. If your service is running locally, you can visit http://127.0.0.1:8000/docs/ to view your documentation.","title":"Access interface document"}]}